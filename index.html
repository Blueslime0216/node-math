<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8"> <!-- 문자 인코딩 설정 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- 반응형 디자인을 위한 뷰포트 설정 -->
    <title>Interactive Grid Canvas</title> <!-- 문서 제목 -->
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: hsl(0, 0%, 10%);
            flex-direction: column;
        }
        canvas {
            border: 0px solid hsl(0, 0%, 90%);
        }
        button {
            margin-bottom: 10px;
            padding: 10px;
            font-size: 16px;
        }
        #btnContainer {
            position: fixed;
            top: 10vh;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1vh;
        }
        #editorSize {
            width: 816px;
            height: 624px;

            border: 2px solid hsl(0, 0%, 90%);

            overflow: hidden;
        }
    </style>
</head>
<body>

    <div id="btnContainer">
        <button id="addNodeBtn">Add Node</button> <!-- 노드 추가 버튼 -->
        <button id="addNodeBtn2">Add Node2</button>
        <button id="addNodeBtn3">Add Node3</button>
        <button id="shortcuts">Shortcuts</button> <!-- 단축키 리스트 버튼 -->
    </div>
    <div id="editorSize">
        <canvas id="editor" width="816" height="624"></canvas> <!-- 그리드 캔버스 -->
    </div>

    <script>
        // 단축키 버튼을 누른 경우 alert 창으로 단축키 목록 표시
        document.getElementById('shortcuts').addEventListener('click', () => {
            alert('< Shortcuts >\n\n' +
                '시점 이동 : 마우스 휠 드래그\n' +
                '확대/축소 : 마우스 휠 스크롤\n' +
                '노드 선택 : 노드 좌클릭\n' +
                '노드 선택 취소 : 빈 공간 클릭\n' +
                '다중 선택 : Shift + 좌클릭\n' +
                '다중 선택 중 단일 선택 : 노드 좌클릭\n' +
                '노드 이동 : 노드 좌클릭 후 드래그\n' +
                '격자에 맞춰서 이동 : Ctrl + 드래그\n' +
                '(노드 이동 중 시점 이동 가능)\n' +
                '(다중 선택 시 즉시 드래그 안 되게 설정)\n' +
                '(겹치는 경우 마지막으로 선택된 노드가 위로 올라옴)\n' +
                '드래그 선택 : 빈 공간에 좌클릭 후 드래그\n'
            );
        });
    </script>
    <script>
        // ============================================================
        // 각종 변수 선언
        // ============================================================
        // 디버깅용 (디버깅)
        let debug = {
            show_nodeCenter: false, // 노드 중심(좌표) 표시
            show_nodeHitbox: false, // 노드 판정 영역 표시
            show_socketHitbox: false, // 소켓 판정 영역 표시
            log_renderedNodes: [false, 0], // 렌더링 된 노드 개수 로깅 [on/off, 개수를 저장할 변수]
        }

        // 요소 가져오기
        const canvas = document.getElementById('editor'); // 캔버스 가져오기
            const ctx = canvas.getContext('2d'); // 2D 렌더링 컨텍스트 가져오기

        // 그리드 관련
        let gridSpacing = 40; // 그리드 간격 설정 (픽셀 단위)
        const minGridSpacing = 10; // 그리드 간격의 최소값 설정
        const maxGridSpacing = 100; // 그리드 간격의 최대값 설정
        // 시점 조작 관련
        let moveX = 0; // X축 방향으로의 이동량
        let moveY = 0; // Y축 방향으로의 이동량
        const zoomFactor = 1.1; // 줌 인/아웃 시 사용할 배율
        // 마우스 관련
        let isLeftMouseDown = false; // 왼쪽 마우스 버튼 클릭 상태 (드래그/단일 선택 판단을 위한)
        let isMouseDragging = false; // 마우스가 실재로 움직이는 드래그 중인지 여부
        let isWheelDragging = false; // 마우스 휠 클릭으로 드래그 중인지 여부
        let moveXStart, moveYStart; // 드래그 시작 지점의 X, Y 좌표
        
        // 드래그 조작 관련
        let mx, my; // 마우스 클릭 위치 X, Y 좌표
        let isNodeDragging = false; // 노드를 드래그 중인지 여부

        let isSocketDragging = false; // 소켓을 드래그 중인지 여부

        let isDragSelecting = false; // 드래그 선택 중인지 여부
        let selectionStartX,
            selectionStartY,
            selectionEndX,
            selectionEndY; // 선택 영역의 시작과 끝 좌표
        let selectionStartInitialX,
            selectionStartInitialY,
            selectionEndInitialX,
            selectionEndInitialY; // 선택 영역들의 초기 좌표
        let onAnimation = {
            selectionBox: null, // 선택 영역 박스 애니메이션을 위한 requestAnimationFram을 저장할 변수
            disconnectOldLine: null, // 연결된 선을 끊는 애니메이션 ~ ~ ~
        }; // 애니메이션을 위한 ref를 저장해둘 변수

        // 노드 관련
        let selectedNodes = []; // 선택된 노드들을 저장할 배열
        let nodes = []; // 노드들을 저장할 배열
        let borderThickness = gridSpacing / 20; // 노드 테두리 두께 계산
        // 소켓 관련
        let hoveredSocket = { // 호버 중인 소켓
            type: null,
            index: null,
            ParentNode: null,
        };
        let selectedSocket = { // 선택된 소켓
            type: null,
            index: null,
            ParentNode: null,
        };
        let socketRadius = gridSpacing / 6; // 소켓 반지름 계산
        // 노드 클래스
        class Node {
            constructor(x, y, type) {
                this.id = Math.random().toString(36).substring(2, 18); // ID 생성
                this.type = type; // 노드 타입
                
                // 홀수로 설정하자(그래야 그리드에 예쁘게 맞춰짐)
                this.width = 3; // 노드의 너비 (그리드 단위)
                this.height = 3; // 노드의 높이 (그리드 단위)

                this.color = 'normal'; // 노드의 스타일 [normal, hover, selected ]

                this.initialX = x; // 초기 X 좌표
                this.initialY = y; // 초기 Y 좌표

                this.offsetX = 0; // X축 방향 오프셋
                this.offsetY = 0; // Y축 방향 오프셋

                this.connections = {
                    input: {
                        socketCount: 0, // 입력 소켓 개수
                        nodes : [], // 입력 소켓에 연결된 노드들을 저장할 배열
                    },
                    output: {
                        socketCount: 0, // 출력 소켓 개수
                        nodes: [], // 출력 소켓에 연결된 노드들을 저장할 배열
                    }
                };
                if (this.type === 'value') { // 노드 타입이 변수 노드라면
                    this.connections.input.socketCount = 0;
                    this.connections.output.socketCount = 1;
                } else if (this.type === 'operator') { // 노드 타입이 연산 노드라면
                    this.connections.input.socketCount = 2;
                    this.connections.output.socketCount = 1;
                } else if (this.type === 'test') { // 노드 타입이 함수 노드라면
                    this.connections.input.socketCount = 5;
                    this.connections.output.socketCount = 5;
                }
                // 동적으로 소켓 개수만큼 빈 배열 생성
                this.connections.input.nodes = Array.from({ length: this.connections.input.socketCount }, () => ({ id: null, index: null, state: null }));
                this.connections.output.nodes = Array.from({ length: this.connections.output.socketCount }, () => ({ id: [null], index: [null], state: [null] }));
                // 높이 다시 계산
                this.height = Math.max(this.connections.input.socketCount, this.connections.output.socketCount) + 2;
            }

            get x() {
                return this.initialX + moveX; // 현재 X 좌표를 계산해서 반환
            }

            get y() {
                return this.initialY + moveY; // 현재 Y 좌표를 계산해서 반환
            }

            draw() {
                borderThickness = gridSpacing / 20; // 테두리 두께 계산
                const borderRadius = borderThickness * 2; // 테두리 둥글기 계산

                ctx.strokeStyle = 'hsl(210, 15%, 100%)'; // 테두리 색상 설정
                ctx.lineWidth = borderThickness; // 테두리 두께 설정

                // 색상 설정
                if (selectedNodes.includes(this)) { // 노드가 선택된 상태라면
                    ctx.fillStyle = 'hsl(210, 70%, 65%)';
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = borderThickness * 2;
                } else if (hoveredSocket.ParentNode === this) { // 소켓이 호버 중인 상태라면
                    ctx.fillStyle = 'hsl(210, 70%, 50%)'; // 기본 상태의 색상
                } else if (this.color === 'hover') { // 호버 상태라면
                    ctx.fillStyle = 'hsl(210, 70%, 55%)';
                } else { // 기본 상태이면
                    ctx.fillStyle = 'hsl(210, 70%, 50%)';
                }

                // 노드 그리기
                ctx.beginPath(); // 그리기 시작
                const width = this.width * gridSpacing; // 너비 계산
                const height = this.height * gridSpacing; // 높이 계산
                ctx.roundRect(this.x - width / 2, this.y - gridSpacing/2, width, height, borderRadius); // 둥근 사각형 형태로 그리기
                ctx.fill(); // 노드 내부 채우기
                ctx.stroke(); // 노드 테두리 그리기

                // 가로선을 그려서 헤더 분할
                ctx.beginPath(); // 그리기 시작
                ctx.moveTo(this.x - width / 2, this.y + gridSpacing/2); // 시작점 설정
                ctx.lineTo(this.x + width / 2, this.y + gridSpacing/2); // 끝점 설정
                ctx.stroke(); // 가로선 그리기

                // 소켓 그리기
                // (인풋 소켓은 왼쪽, 아웃풋 소켓은 오른쪽에 동그란 원 모양으로 그리기)
                socketRadius = gridSpacing / 6; // 소켓 반지름 계산
                const socketY = this.y + gridSpacing/2*3; // 소켓의 초기 Y 좌표 계산
                // 인풋 소켓 그리기
                for (let i = 0; i < this.connections.input.socketCount; i++) {
                    const socketX = this.x - (this.width * gridSpacing)/2; // 인풋 소켓의 X 좌표 계산
                    ctx.beginPath();
                    ctx.arc(socketX, socketY + i * gridSpacing, socketRadius, 0, 2 * Math.PI); // 원 그리기
                    if (hoveredSocket === undefined || !(hoveredSocket.type === 'input' && hoveredSocket.index === i && hoveredSocket.ParentNode === this)) { // 기본 상태라면
                        ctx.fillStyle = 'hsl(210, 70%, 30%)';
                    } else if (hoveredSocket.type === 'input' && hoveredSocket.index === i && hoveredSocket.ParentNode === this) { // 만약 hoveredSocket이 이 소켓이면
                        ctx.fillStyle = 'hsl(210, 70%, 80%)';
                    }
                    ctx.fill(); // 소켓 내부 채우기
                    ctx.stroke(); // 소켓 테두리 그리기
                }
                // 아웃풋 소켓 그리기
                for (let i = 0; i < this.connections.output.socketCount; i++) {
                    const socketX = this.x + (this.width * gridSpacing)/2; // 아웃풋 소켓의 X 좌표 계산
                    ctx.beginPath();
                    ctx.arc(socketX, socketY + i * gridSpacing, socketRadius, 0, 2 * Math.PI); // 원 그리기
                    if (hoveredSocket === undefined || !(hoveredSocket.type === 'output' && hoveredSocket.index === i && hoveredSocket.ParentNode === this)) { // 기본 상태라면
                        ctx.fillStyle = 'hsl(210, 70%, 30%)';
                    } else if (hoveredSocket.type === 'output' && hoveredSocket.index === i && hoveredSocket.ParentNode === this) { // 만약 hoveredSocket이 이 소켓이면
                        ctx.fillStyle = 'hsl(210, 70%, 80%)';
                    }
                    ctx.fill(); // 소켓 내부 채우기
                    ctx.stroke(); // 소켓 테두리 그리기
                }

                // 반투명하게 노드 판정 영역을 박스로 표시 (디버깅)
                if (debug.show_nodeHitbox) {
                    ctx.strokeStyle = 'red'; // 테두리 색상 설정
                    ctx.lineWidth = 2; // 테두리 두께 설정
                    ctx.strokeRect(this.x - width / 2, this.y - gridSpacing/2, width, height); // 노드 판정 영역 그리기
                    // 반투명하게 안을 채우기
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // 채우기 색상 설정
                    ctx.fillRect(this.x - width / 2, this.y - gridSpacing/2, width, height); // 노드 판정 영역 채우기
                }
                // 반투명하게 소켓 판정 영역을 원으로 표시 (디버깅)
                if (debug.show_socketHitbox) {
                    ctx.strokeStyle = 'red'; // 테두리 색상 설정
                    ctx.lineWidth = 2; // 테두리 두께 설정
                    // 인풋 소켓 판정 영역 그리기
                    for (let i = 0; i < this.connections.input.socketCount; i++) {
                        const socketX = this.x - (this.width * gridSpacing)/2; // 인풋 소켓의 X 좌표 계산
                        ctx.beginPath(); // 그리기 시작
                        let socketRadiusMultiplier = isSocketDragging ? 2 : 1; // 소켓 판정 영역 반지름 배율 설정
                        ctx.arc(socketX, socketY + i * gridSpacing, socketRadius*socketRadiusMultiplier, 0, 2 * Math.PI); // 원 그리기
                        ctx.stroke(); // 소켓 테두리 그리기
                        // 반투명하게 안을 채우기
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // 채우기 색상 설정
                        ctx.fill(); // 소켓 내부 채우기
                    }
                    // 아웃풋 소켓 판정 영역 그리기
                    for (let i = 0; i < this.connections.output.socketCount; i++) {
                        const socketX = this.x + (this.width * gridSpacing)/2; // 아웃풋 소켓의 X 좌표 계산
                        ctx.beginPath(); // 그리기 시작
                        let socketRadiusMultiplier = isSocketDragging ? 2 : 1; // 소켓 판정 영역 반지름 배율 설정
                        ctx.arc(socketX, socketY + i * gridSpacing, socketRadius*socketRadiusMultiplier, 0, 2 * Math.PI); // 원 그리기
                        ctx.stroke(); // 소켓 테두리 그리기
                        // 반투명하게 안을 채우기
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // 채우기 색상 설정
                        ctx.fill(); // 소켓 내부 채우기
                    }
                }
                // 중심 표시 (디버깅)
                if (debug.show_nodeCenter) {
                    ctx.beginPath(); // 그리기 시작
                    ctx.arc(this.x, this.y, borderThickness * 2, 0, 2 * Math.PI); // 원 그리기
                    ctx.fillStyle = 'orange'; // 원 색상 설정
                    ctx.fill(); // 원 내부 채우기
                }
            }

            contains(mx, my) { // 주어진 좌표가 노드 내부인지 확인
                return mx >= this.x - this.width * gridSpacing / 2 && mx <= this.x + this.width * gridSpacing / 2 &&
                       my >= this.y - gridSpacing/2 && my <= this.y - gridSpacing/2 + this.height * gridSpacing;
            }
            // 주어진 좌표가 소켓 내부인지 확인
            containsSocket(mx, my) {
                const socketY = this.y + gridSpacing/2*3; // 소켓의 초기 Y 좌표 계산
                socketRadius = (gridSpacing / 6)*(isSocketDragging ? 2 : 1); // 소켓 반지름 계산
                // 인풋 소켓 확인
                for (let i = 0; i < this.connections.input.socketCount; i++) {
                    const socketX = this.x - (this.width * gridSpacing)/2; // 인풋 소켓의 X 좌표 계산
                    if (Math.sqrt((mx - socketX) ** 2 + (my - (socketY + i * gridSpacing)) ** 2) <= socketRadius) {
                        return { type: 'input', index: i }; // 인풋 소켓이면 인풋 소켓 타입과 인덱스 반환
                    }
                }
                // 아웃풋 소켓 확인
                for (let i = 0; i < this.connections.output.socketCount; i++) {
                    const socketX = this.x + (this.width * gridSpacing)/2; // 아웃풋 소켓의 X 좌표 계산
                    if (Math.sqrt((mx - socketX) ** 2 + (my - (socketY + i * gridSpacing)) ** 2) <= socketRadius) {
                        return { type: 'output', index: i }; // 아웃풋 소켓이면 아웃풋 소켓 타입과 인덱스 반환
                    }
                }
                return null; // 소켓이 아니면 null 반환
            }
        }



        // ============================================================
        // 함수 선언
        // ============================================================
        // 최종적인 캔버스를 그리는 함수
        function updateCanvas(e) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 캔버스 지우기

            drawGrid(); // 그리드 그리기

            // 연결된 소켓 선 그리기
            drawSocketConnections();

            // 렌더링 된 노드 개수 띄우기 (디버깅)
            if (debug.log_renderedNodes[0]) { 
                debug.log_renderedNodes[1] = 0;

                // 노드들을 그리기
                nodes.forEach(node => {
                    const nodeWidth = node.width * gridSpacing / 2 + socketRadius; // 이 노드의 너비
                    const nodeHeight = node.height * gridSpacing; // 이 노드의 높이
                    if (node.x + nodeWidth >= 0 && node.x - nodeWidth <= canvas.width
                            && node.y - gridSpacing/2 + nodeHeight >= 0 && node.y - gridSpacing/2 <= canvas.height) {
                        node.draw(); // 노드 그리기
                        debug.log_renderedNodes[1]++;
                    }
                });

                console.log("렌더링 된 노드 개수 : "+debug.log_renderedNodes[1]);
            } else {
                // 위랑 같은 코드임 
                nodes.forEach(node => {
                    const nodeWidth = node.width * gridSpacing / 2 + socketRadius; // 이 노드의 너비
                    const nodeHeight = node.height * gridSpacing; // 이 노드의 높이
                    if (node.x + nodeWidth >= 0 && node.x - nodeWidth <= canvas.width
                            && node.y - gridSpacing/2 + nodeHeight >= 0 && node.y - gridSpacing/2 <= canvas.height) {
                        node.draw(); // 노드 그리기
                    }
                });
            }

            if (isDragSelecting) {
                drawSelectionBox(); // 드래그로 선택된 영역 그리기
            }

            if (!(selectedSocket.type === null)) {
                drawSocketConnecting(e); // 당겨지고 있는 소켓 연결 선 그리기
            }
        }

        // 그리드를 그리는 함수
        function drawGrid() {
            ctx.lineWidth = 1; // 그리드 선 두께 설정
            ctx.strokeStyle = 'hsl(0, 0%, 25%)'; // 그리드 선 색상 설정
            // // 그리드 간격이 최소값보다 작으면 최소값으로, 최대값보다 크면 최대값으로 설정 (??? 일단 비활성화)
            // gridSpacing = Math.max(minGridSpacing, Math.min(maxGridSpacing, gridSpacing));

            // 수직선 그리기
            for (let x = moveX % gridSpacing; x < canvas.width; x += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            // 수평선 그리기
            for (let y = moveY % gridSpacing; y < canvas.height; y += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // 드래그로 선택된 영역을 그리는 함수
        function drawSelectionBox() {
            const x = Math.min(selectionStartX, selectionEndX); // 시작점 X 좌표
            const y = Math.min(selectionStartY, selectionEndY); // 시작점 Y 좌표
            const width = Math.abs(selectionEndX - selectionStartX); // 너비 계산
            const height = Math.abs(selectionEndY - selectionStartY); // 높이 계산

            ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)'; // 드래그 선택 영역 테두리 색상
            ctx.lineWidth = 4; // 드래그 선택 영역 테두리 두께
            ctx.setLineDash([6,4]); // 점선 패턴 설정
            ctx.lineDashOffset = -(Date.now() / 1000).toString().split('.')[1]?.slice(0, 1) * 2 || 0; // 점선 오프셋 설정
            ctx.strokeRect(x, y, width, height); // 드래그 선택 영역 그리기
            ctx.setLineDash([]); // 점선 패턴 해제
        }

        // 드래그로 선택된 영역 내의 노드들을 선택하는 함수
        function selectNodesInBox() {
            const x1 = Math.min(selectionStartX, selectionEndX); // 시작점 X 좌표
            const y1 = Math.min(selectionStartY, selectionEndY); // 시작점 Y 좌표
            const x2 = Math.max(selectionStartX, selectionEndX); // 끝점 X 좌표
            const y2 = Math.max(selectionStartY, selectionEndY); // 끝점 Y 좌표

            // 선택 영역 내의 노드들을 찾아 선택
            selectedNodes = nodes.filter(node => { // 모든 노드들 중에서
                const nodeX = node.x; // 이 노드의 X 좌표
                const nodeY = node.y; // 이 노드의 Y 좌표
                const nodeWidth = node.width * gridSpacing / 2; // 이 노드의 너비
                const nodeHeight = node.height * gridSpacing; // 이 노드의 높이

                // 선택 영역 내에 있는지 계산해서 반환
                return (nodeX + nodeWidth >= x1 && nodeX - nodeWidth <= x2 &&
                        nodeY - gridSpacing/2 + nodeHeight >= y1 && nodeY - gridSpacing/2 <= y2);
            });
        }

        // 연결되어 있는 소켓 연결선을 그리는 함수
        function drawSocketConnections() {
            // 모든 노드들의 소켓들을 연결하는 선 그리기
            nodes.forEach(node => {
                const socketY = node.y + gridSpacing/2*3; // 소켓의 초기 Y 좌표 계산
                const socketRadius = gridSpacing / 6; // 소켓 반지름 계산
                // 아웃풋 소켓 연결 선 그리기
                const socketX = node.x + (node.width * gridSpacing)/2; // 아웃풋 소켓의 X 좌표 계산
                for (let i = 0; i < node.connections.output.socketCount; i++) { // 각각의 아웃풋 소켓에 대해서
                    for (let j = 0; j < node.connections.output.nodes[i].id.length; j++) { // j를 추가해서 한 아웃풋에서 여러개로 나가는 거 구현
                        if (node.connections.output.nodes[i].state[j]) {
                            const connectedNode = nodes.find(n => n.id === node.connections.output.nodes[i].id[j]); // 연결된 노드 찾기
                            const connectedSocketY = connectedNode.y + gridSpacing/2*3; // 연결된 소켓의 초기 Y 좌표 계산
                            const connectedSocketX = connectedNode.x - (connectedNode.width * gridSpacing)/2; // 연결된 소켓의 X 좌표 계산
                            ctx.beginPath(); // 그리기 시작
                            ctx.moveTo(socketX, socketY + i * gridSpacing); // 시작점 설정
                            ctx.lineTo(connectedSocketX, connectedSocketY + node.connections.output.nodes[i].index[j] * gridSpacing); // 끝점 설정
                            ctx.strokeStyle = 'hsl(210, 15%, 100%)'; // 선 색상 설정
                            ctx.lineWidth = borderThickness*2; // 선 두께 설정
                            // 지금 이 소켓이 연결한 소켓에 유저가 다른 소켓을 연결할려고 한다면
                            if (selectedSocket.type != null && hoveredSocket.type !== null && selectedSocket.type === 'output' && hoveredSocket.type === 'input'
                            && hoveredSocket.ParentNode.id === node.connections.output.nodes[i].id[j] && hoveredSocket.index === node.connections.output.nodes[i].index[j]) {
                                ctx.strokeStyle = 'hsla(210, 15%, 100%, 0.5)'; // 선 색상을 투명하게 설정
                                // 점선으로 표시
                                ctx.setLineDash([gridSpacing/4,gridSpacing/4]); // 점선 패턴 설정
                            }
                            ctx.stroke(); // 선 그리기
                            ctx.setLineDash([]); // 점선 패턴 해제
                        }
                    }
                }
            });
        }
        // 드래그 연결 중인 소켓 연결선을 그리는 함수
        function drawSocketConnecting(e) {
            // 선택된 소켓의 위치부터 마우스 위치까지 선 그리기
            const socketY = selectedSocket.ParentNode.y + gridSpacing/2*3; // 소켓의 초기 Y 좌표 계산
            const socketRadius = gridSpacing / 6; // 소켓 반지름 계산
            let socketX;
            if (selectedSocket.type === 'input') {
                socketX = selectedSocket.ParentNode.x - (selectedSocket.ParentNode.width * gridSpacing)/2; // 인풋 소켓의 X 좌표 계산
            } else if (selectedSocket.type === 'output') {
                socketX = selectedSocket.ParentNode.x + (selectedSocket.ParentNode.width * gridSpacing)/2; // 아웃풋 소켓의 X 좌표 계산
            }
            ctx.beginPath(); // 그리기 시작
            ctx.moveTo(socketX, socketY + selectedSocket.index * gridSpacing); // 시작점 설정
            let connectionEndX = e.offsetX; // 연결 끝점 X 좌표
            let connectionEndY = e.offsetY; // 연결 끝점 Y 좌표
            // 만약 마우스가 다른 소켓 위에 있고 해당 소켓이 인풋 소켓이고
            if (!(selectedSocket.type === null) && hoveredSocket.type !== null && selectedSocket.ParentNode !== hoveredSocket.ParentNode && (selectedSocket.type === 'output' && hoveredSocket.type === 'input')) {
                // if (selectedSocket.ParentNode.connections.output.nodes[selectedSocket.index].id.includes(hoveredSocket.ParentNode.id) && selectedSocket.ParentNode.connections.output.nodes[selectedSocket.index].index.includes(hoveredSocket.index)) {
                //     // 연결하려는 소켓이 자신과 이미 연결된 상태라면 아무 효과도 주지 않기
                //     ctx.strokeStyle = 'hsla(210, 15%, 100%, 0.5)'; // 선 색상 설정
                //     ctx.lineWidth = borderThickness*2; // 선 두께 설정
                //     ctx.fillStyle = 'hsl(210, 15%, 100%)'; // 원 색상 설정
                // } else 
                if (hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].state == "connect") {
                    // 연결하려는 소켓이 이미 다른 소켓과 연결된 상태라면
                    console.log("이미 연결된 소켓입니다.");
                    connectionEndX = hoveredSocket.ParentNode.x - (hoveredSocket.ParentNode.width * gridSpacing)/2;
                    connectionEndY = hoveredSocket.ParentNode.y + gridSpacing/2*3 + hoveredSocket.index * gridSpacing;
    
                    ctx.strokeStyle = 'hsl(210, 15%, 100%)'; // 선 색상 설정
                    ctx.lineWidth = socketRadius; // 선 두께 설정
                    ctx.fillStyle = 'hsl(210, 15%, 100%)'; // 원 색상 설정
                } else { // 연결되지 않은 상태라면
                    // 소켓끼리 잇기
                    connectionEndX = hoveredSocket.ParentNode.x - (hoveredSocket.ParentNode.width * gridSpacing)/2;
                    connectionEndY = hoveredSocket.ParentNode.y + gridSpacing/2*3 + hoveredSocket.index * gridSpacing;
    
                    ctx.strokeStyle = 'hsl(210, 15%, 100%)'; // 선 색상 설정
                    ctx.lineWidth = socketRadius; // 선 두께 설정
                    ctx.fillStyle = 'hsl(210, 15%, 100%)'; // 원 색상 설정
                }
            } else {
                ctx.strokeStyle = 'hsla(210, 15%, 100%, 0.5)'; // 선 색상 설정
                ctx.lineWidth = borderThickness*2; // 선 두께 설정
                ctx.fillStyle = 'hsl(210, 15%, 100%)'; // 원 색상 설정
            }
            ctx.lineTo(connectionEndX, connectionEndY);
            ctx.stroke(); // 선 그리기
            // 시작점에 원 그리기
            ctx.beginPath(); // 그리기 시작
            ctx.arc(socketX, socketY + selectedSocket.index * gridSpacing, socketRadius/2, 0, 2 * Math.PI); // 원 그리기
            ctx.fill(); // 원 내부 채우기
            // 마우스 위치에 원 그리기
            ctx.beginPath(); // 그리기 시작
            ctx.arc(connectionEndX, connectionEndY, socketRadius/2, 0, 2 * Math.PI); // 원 그리기
            ctx.fill(); // 원 내부 채우기
        }


        // ============================================================
        // 이벤트 리스너 등록
        // ============================================================
        // 마우스 휠을 돌렸을 때
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // 기본 스크롤 동작 방지

            const mouseX = e.offsetX; // 스크롤이 발생하고 있는 지금 마우스 X 좌표
            const mouseY = e.offsetY; // 스크롤이 발생하고 있는 지금 마우스 Y 좌표

            const zoomAmount = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor; // 줌 방향(in/out) 계산
            gridSpacing *= zoomAmount; // 그리드 간격 변경(= 줌 조정)

            // 마우스 위치를 기준으로 줌이 조정되도록 시점 이동
            moveX += (mouseX - moveX) * (1 - zoomAmount);
            moveY += (mouseY - moveY) * (1 - zoomAmount);

            // 모든 노드의 위치 조정 (너비와 높이는 gridSpacing에 의해 자동 조정됨)
            nodes.forEach(node => {
                node.offsetX *= zoomAmount;
                node.offsetY *= zoomAmount;
                node.initialX *= zoomAmount;
                node.initialY *= zoomAmount;
            });

            // 드래그 선택 영역 시작점 위치 조정
            if (isDragSelecting) {
                selectionStartX = (selectionStartX - mouseX) * zoomAmount + mouseX;
                selectionStartY = (selectionStartY - mouseY) * zoomAmount + mouseY;
            }

            updateCanvas(e); // 캔버스 업데이트
        });

        // 마우스 클릭 시
        canvas.addEventListener('mousedown', (e) => {
            mx = e.offsetX; // 마우스 클릭 위치 X 좌표
            my = e.offsetY; // 마우스 클릭 위치 Y 좌표
            selectionStartInitialX = selectionStartX; // 드래그 선택 시작점 초기 X 좌표
            selectionStartInitialY = selectionStartY; // 드래그 선택 시작점 초기 Y 좌표
            selectionEndInitialX = selectionEndX; // 드래그 선택 끝점 초기 X 좌표
            selectionEndInitialY = selectionEndY; // 드래그 선택 끝점 초기 Y 좌표


            if (e.button === 1) { // 마우스 휠을 누른 거라면
                isWheelDragging = true; // 휠 드래그 시작
                moveXStart = e.clientX - moveX; // 이동 시작 X 좌표
                moveYStart = e.clientY - moveY; // 이동 시작 Y 좌표

            } else if (e.button === 0) { // 마우스 좌클릭을 한 거라면
                isLeftMouseDown = true; // 드래그/단일 선택 판단을 위한 좌클릭 상태 설정

                // 클릭된 노드가 있나 찾기
                const clickedNode = nodes.slice().reverse().find(node => node.contains(mx, my));
                // 클릭된 소켓이 있나 찾기
                selectedSocket = hoveredSocket; // 선택된 소켓 설정
                // 클릭된 노드를 앞으로 끌어오는 코드
                if (clickedNode) {
                    const index = nodes.indexOf(clickedNode); // 선택된 노드의 인덱스 찾기
                    if (index !== -1) {
                        nodes.splice(index, 1); // 선택된 노드를 배열에서 제거
                        nodes.push(clickedNode); // 선택된 노드를 배열의 최하위로 추가
                    }
                } else if (selectedSocket.ParentNode) { // 소켓이 클릭되면 해당 노드를 앞에 보이게 하기
                    const index = nodes.indexOf(selectedSocket.ParentNode); // 선택된 노드의 인덱스 찾기
                    if (index !== -1) {
                        nodes.splice(index, 1); // 선택된 노드를 배열에서 제거
                        nodes.push(selectedSocket.ParentNode); // 선택된 노드를 배열의 최하위로 추가
                    }
                }

                if (e.shiftKey) { // Shift가 같이 눌린 경우 다중 선택 기능
                    if (clickedNode && !selectedNodes.includes(clickedNode)) { // 선택된 노드가 있고, selectedNodes에 없다면
                        selectedNodes.push(clickedNode); // 선택된 노드들에 추가
                    } else if (clickedNode && selectedNodes.includes(clickedNode)) {// 선택된 노드가 있고, selectedNodes에 있다면
                        selectedNodes = selectedNodes.filter(node => node !== clickedNode); // 선택된 노드들에서 제거
                    }
 
                } else { // 좌클릭만 한 경우
                    if (clickedNode && (selectedSocket.type === null)) { // 클릭된 노드가 있고 선택된 소켓이 없다면
                        // 선택된 노드가 selectedNodes에 있는 노드가 아니면
                        if (!selectedNodes.includes(clickedNode)) { // 단일 선택
                            selectedNodes = [clickedNode];
                        } else {// 선택된 노드가 selectedNodes에 있는 노드라면(= (다중) 선택 된 단일 요소 클릭)
                            // 드래그인지 단일 클릭인지 판단
                            let waitInterval = setInterval(() => {
                                // 드래그 시 드래그라고 판단
                                if (isMouseDragging) {
                                    clearInterval(waitInterval); // 인터벌 삭제
                                }

                                // 클릭 해제 시 단일 선택이라고 판단
                                if (!isLeftMouseDown) {
                                    selectedNodes = [clickedNode]; // 단일 선택

                                    updateCanvas(e); // 캔버스 업데이트(인터벌이라 아래의 업데이트가 안 돼서 여기서 업데이트)

                                    clearInterval(waitInterval); // 인터벌 삭제
                                }
                            }, 10); // 일정 시간 간격으로 확인
                        }
                    } else if (!(selectedSocket.type === null)) { // 소켓이 선택되었다면
                        isSocketDragging = true; // 소켓 드래그 상태 설정
                        selectedNodes = []; // 배열 비우기
                    } else { // 클릭된 노드가 없으면(= 빈 공간 클릭)
                        selectedNodes = []; // 배열 비우기
                    }
                }
                

                // 드래그 시작
                // 클릭된 노드가 있고, Shift가 눌리지 않았고, 소켓이 선택되지 않았다면 드래그라고 판단
                if (clickedNode && !e.shiftKey && selectedSocket.type === null) {
                    isNodeDragging = true; // 드래그 상태 설정

                    // 선택된 노드들의 오프셋을 각각 계산
                    selectedNodes.forEach(node => {
                        node.offsetX = mx - node.x; // X 방향 오프셋 계산
                        node.offsetY = my - node.y; // Y 방향 오프셋 계산
                    });
                }
                
                // 드래그 선택이 시작되면
                // Shift가 눌리지 않았고, 드래그 중인 노드가 없고, 소켓이 선택되지 않았다면 드래그 선택이라고 판단
                if (!e.shiftKey && !isNodeDragging && selectedSocket.type === null) {
                    isDragSelecting = true;
                    selectionStartX = e.offsetX;
                    selectionStartY = e.offsetY;
                    selectionEndX = e.offsetX;
                    selectionEndY = e.offsetY;

                    function selectionBox() {
                        updateCanvas(e);
                        console.log("드래그 선택 중");

                        onAnimation.selectionBox = requestAnimationFrame(selectionBox);
                    }
                    selectionBox(); // 애니메이션 주기
                } else { // 드래그 선택이 아니라면 그냥 캔버스 업데이트
                    updateCanvas(e);
                }
            }
        });

        // 마우스가 움직이면(캔버스 측 처리)
        canvas.addEventListener('mousemove', (e) => {
            const hoveredNode = nodes.slice().reverse().find(node => node.contains(mx, my)); // 호버 중인 노드 찾기
            hoveredSocket = nodes.find(node => node.containsSocket(mx, my))?.containsSocket(mx, my) || { type: null, index: null }; // 호버 중인 소켓 찾기
            // 호버된 소켓을 가지고 있는 노드 찾기
            hoveredSocket.ParentNode = nodes.find(node => node.containsSocket(mx, my));

            // 마우스가 노드 위에 있으면 노드 스타일 변경
            nodes.forEach(node => {
                if (selectedNodes.includes(node)) { // 선택된 노드라면
                    // (!!!) 하지만 selectedNodes에 있는 노드에 스타일을 적용하는 시스템이라서 이 코드는 아직까지는 의미가 없음
                    node.color = 'selected';
                } else if (node === hoveredNode) { // 호버 중인 노드라면
                    node.color = 'hover';
                } else { // 아니라면
                    node.color = 'normal';
                }
            });

            // 드래그 선택 중인 경우
            if (isDragSelecting) {
                selectionEndX = e.offsetX; // 드래그 선택 끝점 X 좌표
                selectionEndY = e.offsetY; // 드래그 선택 끝점 Y 좌표

                selectNodesInBox(); // 드래그로 선택된 영역 내의 노드들을 선택처리
            }
            
            updateCanvas(e); // 캔버스 업데이트
        });

        // 마우스가 움직이면
        window.addEventListener('mousemove', (e) =>{
            // 마우스가 캔버스 밖으로 나가도 드래그가 되도록 조정하는 코드
            if (e.target === canvas) {
                mx = e.offsetX; // 마우스 X 좌표
                my = e.offsetY; // 마우스 Y 좌표
            } else {
                mx = e.offsetX - canvas.getBoundingClientRect().left; // 마우스 X 좌표
                my = e.offsetY - canvas.getBoundingClientRect().top; // 마우스 Y 좌표
            }

            // 마우스가 실재로 움직이는 드래그 중인지 판단
            if (isNodeDragging) {
                isMouseDragging = true;
            } else {
                isMouseDragging = false;
            }

            // 휠 드래그 중인지 판단
            if (isWheelDragging) { // 휠 드래그 중인 경우
                // 시점 이동 처리
                moveX = e.clientX - moveXStart; // X축 방향 이동량 계산
                moveY = e.clientY - moveYStart; // Y축 방향 이동량 계산
                
                // 드래그 선택 중인 경우, 드래그 박스의 시작 지점도 이동
                if (isDragSelecting) {
                    selectionStartX = e.offsetX + (selectionStartInitialX - selectionEndInitialX);
                    selectionStartY = e.offsetY + (selectionStartInitialY - selectionEndInitialY);
                }
            } else if (isNodeDragging) { // 좌클릭 드래그 중인 경우
                // 선택된 노드들의 위치를 마우스 위치에 따라 이동
                selectedNodes.forEach(node => {
                    // Ctrl 키를 누르고 있는 경우 그리드에 맞춰 이동
                    if (e.ctrlKey) {
                        node.initialX = Math.round((mx - node.offsetX - moveX) / gridSpacing) * gridSpacing;
                        node.initialY = Math.round((my - node.offsetY - moveY) / gridSpacing) * gridSpacing;
                    } else { // 아니라면 그냥 이동
                        node.initialX = mx - node.offsetX - moveX;
                        node.initialY = my - node.offsetY - moveY;
                    }
                });
            }


            updateCanvas(e); // 캔버스 업데이트
        });

        // 마우스 클릭을 뗐을 때
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) { // 좌클릭을 뗐을 때
                isNodeDragging = false; // 드래그 상태 해제
                isLeftMouseDown = false; // 좌클릭 상태 해제
                isSocketDragging = false; // 소켓 드래그 상태 해제
                if (selectedSocket.type !== null && hoveredSocket.type !== null && selectedSocket.ParentNode !== hoveredSocket.ParentNode) {
                    // 소켓 연결이 된 상태(드래그 선택된 소켓이 있고, 호버된 소켓이 있고, 선택된 소켓과 호버된 소켓이 다른 노드일 때)에서 마우스를 뗀 경우
                    if (hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].state == "connect") {
                        // 이전에 연결된 소켓을 찾아서 연결 해제하기

                        // 지금 연결하려는 소켓이 연결되어 있는 소켓의 경로
                        const connectedNode = nodes.find(node => node.id === hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].id);
                        const connectedSK = connectedNode.connections.output.nodes[hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].index];
                        // connectedSK의 id와 index와 state를 제거하기
                        const index = connectedSK.id.findIndex((id, i) => id === hoveredSocket.ParentNode.id && connectedSK.index[i] === hoveredSocket.index);
                        connectedSK.id.splice(index, 1);
                        connectedSK.index.splice(index, 1);
                        connectedSK.state.splice(index, 1);
                        console.log(`(연결 해제됨 : ${connectedNode.id} ${connectedSK.type} ${connectedSK.index+1}번째 소켓 <- ${hoveredSocket.ParentNode.id} ${hoveredSocket.type} ${hoveredSocket.index+1}번째 소켓`);
                    }
                    // 선택된 소켓과 호버된 소켓을 연결하기
                    const selectedSK = selectedSocket.ParentNode.connections.output.nodes[selectedSocket.index];
                    selectedSK.state[selectedSK.state.length - 1] = 'connect';
                    hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].id = selectedSocket.ParentNode.id;
                    hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].index = selectedSocket.index;
                    hoveredSocket.ParentNode.connections.input.nodes[hoveredSocket.index].state = 'connect';
                    selectedSK.id[selectedSK.id.length - 1] = hoveredSocket.ParentNode.id;
                    selectedSK.index[selectedSK.index.length - 1] = hoveredSocket.index;
                    // 새로운 연결줄을 추가하기
                    selectedSK.id.push(null);
                    selectedSK.index.push(null);
                    selectedSK.state.push(null);
                    console.log(`(연결됨 : ${selectedSocket.ParentNode.id} ${selectedSocket.type} ${selectedSocket.index+1}번째 소켓 -> ${hoveredSocket.ParentNode.id} ${hoveredSocket.type} ${hoveredSocket.index+1}번째 소켓`);
                }
                selectedSocket = { type: null, index: null, ParentNode: null }; // 선택된 소켓 초기화

                // 드래그 선택이 종료되는 거라면
                if (isDragSelecting) {
                    isDragSelecting = false; // 드래그 선택 상태 해제

                    cancelAnimationFrame(onAnimation.selectionBox); // 애니메이션 제거
                }
            } else if (e.button === 1) { // 마우스 휠을 뗐을 때
                isWheelDragging = false; // 휠 드래그 상태 해제
            }

            updateCanvas(e); // 캔버스 업데이트
        });

        // del키를 누른 경우
        window.addEventListener('keydown', (e) => {
            // 노드 삭제 기능
            if (e.key === 'Delete') { // del키를 누른 경우
                nodes = nodes.filter(node => !selectedNodes.includes(node)); // 선택된 노드들을 제외한 노드들만 남기기
                selectedNodes = []; // 선택된 노드들 비우기

                updateCanvas(e); // 캔버스 업데이트
            }

            // 전부 선택 기능
            if (e.ctrlKey && e.key === 'a') { // Ctrl + A를 누른 경우
                e.preventDefault(); // 기본 동작 방지
                
                selectedNodes = nodes.slice(); // 모든 노드들을 선택

                updateCanvas(e); // 캔버스 업데이트
            }
        });
        
        // 윈도우 크기가 변경되면 캔버스 크기 업데이트하기
        window.addEventListener('resize', () => {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            updateCanvas();
        });

        // 노드 추가 버튼을 누른 경우
        document.getElementById('addNodeBtn').addEventListener('click', () => {
            const centerX = (canvas.width / 2 - moveX);
            const centerY = (canvas.height / 2 - moveY);
            const node = new Node(centerX, centerY, 'value');

            nodes.push(node);
            
            updateCanvas();
        });
        document.getElementById('addNodeBtn2').addEventListener('click', () => {
            const centerX = (canvas.width / 2 - moveX);
            const centerY = (canvas.height / 2 - moveY);
            const node = new Node(centerX, centerY, 'operator');

            nodes.push(node);
            
            updateCanvas();
        });
        document.getElementById('addNodeBtn3').addEventListener('click', () => {
            const centerX = (canvas.width / 2 - moveX);
            const centerY = (canvas.height / 2 - moveY);
            const node = new Node(centerX, centerY, 'test');

            nodes.push(node);
            
            updateCanvas();
        });

        // ============================================================
        // 코드 실행
        // ============================================================
        updateCanvas(); // 초기 캔버스 업데이트
    </script>
</body>
</html>