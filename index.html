<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8"> <!-- 문자 인코딩 설정 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- 반응형 디자인을 위한 뷰포트 설정 -->
    <title>Interactive Grid Canvas</title> <!-- 문서 제목 -->
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: hsl(0, 0%, 10%);
            flex-direction: column;
        }
        canvas {
            border: 2px solid hsl(0, 0%, 90%);
        }
        button {
            margin-bottom: 10px;
            padding: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>

    <button id="shortcuts">Shortcuts</button> <!-- 단축키 리스트 버튼 -->
    <button id="addNodeBtn">Add Node</button> <!-- 노드 추가 버튼 -->
    <canvas id="gridCanvas" width="816" height="624"></canvas> <!-- 그리드 캔버스 -->

    <script>
        // 단축키 버튼을 누른 경우 alert 창으로 단축키 목록 표시
        document.getElementById('shortcuts').addEventListener('click', () => {
            alert('< Shortcuts >\n\n' +
                '시점 이동 : 마우스 휠 드래그\n' +
                '확대/축소 : 마우스 휠 스크롤\n' +
                '노드 선택 : 노드 좌클릭\n' +
                '노드 선택 취소 : 빈 공간 클릭\n' +
                '다중 선택 : Shift + 좌클릭\n' +
                '다중 선택 중 단일 선택 : 노드 좌클릭\n' +
                '노드 이동 : 노드 좌클릭 후 드래그\n' +
                '격자에 맞춰서 이동 : Ctrl + 드래그\n' +
                '(노드 이동 중 시점 이동 가능)\n' +
                '(다중 선택 시 즉시 드래그 안 되게 설정)\n' +
                '(겹치는 경우 마지막으로 선택된 노드가 위로 올라옴)\n' +
                '드래그 선택 : 빈 공간에 좌클릭 후 드래그\n'
            );
        });
    </script>
    <script>
        const canvas = document.getElementById('gridCanvas'); // 캔버스 요소 선택
        const ctx = canvas.getContext('2d'); // 2D 컨텍스트 가져오기

        let gridSpacing = 40; // 그리드 간격 설정
        let moveX = 0; // X 축 이동값 초기화
        let moveY = 0; // Y 축 이동값 초기화
        const zoomFactor = 1.1; // 줌 배율 설정
        let isLeftMouseDown = false; // 좌클릭 상태 플래그
        let isDragging = false; // 드래그 상태 플래그
        let isMouseDragging = false; // 마우스 드래그 상태 플래그
        let isWheelDragging = false; // 휠 드래그 상태 플래그
        let selectedNodes = []; // 선택된 노드들 배열
        let moveXStart, moveYStart; // 이동 시작 좌표 저장

        const nodes = [];

        let isSelecting = false; // 드래그 선택 상태
        let selectionStartX, selectionStartY; // 드래그 시작 위치
        let selectionEndX, selectionEndY; // 드래그 종료 위치
        let selectionInterval; // 인터벌을 저장할 변수

        class Node {
            constructor(x, y) {
                this.id = Math.random().toString(36).substring(2, 18);
                this.initialX = x;
                this.initialY = y;
                this.offsetX = 0;
                this.offsetY = 0;
                this.width = 3;
                this.height = 5;
                this.color = 'normal';
            }

            get x() {
                return this.initialX + moveX;
            }

            get y() {
                return this.initialY + moveY;
            }

            draw() {
                const size = gridSpacing * 2.5;
                const borderThickness = gridSpacing / 20;
                const borderRadius = borderThickness * 2;

                ctx.strokeStyle = 'hsl(210, 15%, 100%)';
                ctx.lineWidth = borderThickness;

                if (selectedNodes.includes(this)) {
                    ctx.fillStyle = 'hsl(210, 70%, 65%)';
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = borderThickness * 2;
                } else if (this.color === 'hover') {
                    ctx.fillStyle = 'hsl(210, 70%, 55%)';
                } else {
                    ctx.fillStyle = 'hsl(210, 70%, 50%)';
                }
                ctx.beginPath();
                const width = this.width * gridSpacing;
                const height = this.height * gridSpacing;
                ctx.roundRect(this.x - width / 2, this.y - height / 2, width, height, borderRadius);
                ctx.fill();
                ctx.stroke();
            }

            contains(mx, my) {
                return mx >= this.x - this.width * gridSpacing / 2 && mx <= this.x + this.width * gridSpacing / 2 &&
                       my >= this.y - this.height * gridSpacing / 2 && my <= this.y + this.height * gridSpacing / 2;
            }
        }

        function updateCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            nodes.forEach(node => node.draw());
            if (isSelecting) {
                drawSelectionBox();
            }
        }

        function drawGrid() {
            ctx.lineWidth = 1;

            for (let x = moveX % gridSpacing; x < canvas.width; x += gridSpacing) {
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'hsl(0, 0%, 25%)';
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = moveY % gridSpacing; y < canvas.height; y += gridSpacing) {
                ctx.strokeStyle = 'hsl(0, 0%, 25%)';
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // 기본 휠 이벤트 방지

            const mouseX = e.offsetX; // 마우스 X 좌표
            const mouseY = e.offsetY; // 마우스 Y 좌표

            const zoomAmount = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor; // 줌 배율 결정
            gridSpacing *= zoomAmount; // 그리드 간격 조정

            // 마우스 위치에 따라 이동 조정
            moveX += (mouseX - moveX) * (1 - zoomAmount);
            moveY += (mouseY - moveY) * (1 - zoomAmount);

            // 모든 노드의 오프셋 및 위치 조정
            nodes.forEach(node => {
                node.offsetX *= zoomAmount;
                node.offsetY *= zoomAmount;
                node.initialX *= zoomAmount;
                node.initialY *= zoomAmount;
            });

            updateCanvas(); // 캔버스 업데이트
        });

        function drawSelectionBox() {
            const x = Math.min(selectionStartX, selectionEndX);
            const y = Math.min(selectionStartY, selectionEndY);
            const width = Math.abs(selectionEndX - selectionStartX);
            const height = Math.abs(selectionEndY - selectionStartY);

            ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.setLineDash([6,4]);
            let lineDashOffsetValue = (Date.now() / 1000).toString();
            lineDashOffsetValue = lineDashOffsetValue.split('.')[1].slice(0, 1);
            console.log(lineDashOffsetValue);
            ctx.lineDashOffset = -lineDashOffsetValue*2;
            ctx.strokeRect(x, y, width, height);
            ctx.setLineDash([]);
        }
        function selectNodesInBox() {
            const x1 = Math.min(selectionStartX, selectionEndX);
            const y1 = Math.min(selectionStartY, selectionEndY);
            const x2 = Math.max(selectionStartX, selectionEndX);
            const y2 = Math.max(selectionStartY, selectionEndY);

            selectedNodes = nodes.filter(node => {
                const nodeX = node.x;
                const nodeY = node.y;
                const nodeWidth = node.width * gridSpacing / 2;
                const nodeHeight = node.height * gridSpacing / 2;

                return (nodeX + nodeWidth >= x1 && nodeX - nodeWidth <= x2 &&
                        nodeY + nodeHeight >= y1 && nodeY - nodeHeight <= y2);
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            const mx = e.offsetX; // 마우스 클릭 위치 X 좌표
            const my = e.offsetY; // 마우스 클릭 위치 Y 좌표


            if (e.button === 1) {
                isWheelDragging = true; // 휠 드래그 시작
                moveXStart = e.clientX - moveX; // 이동 시작 X 좌표
                moveYStart = e.clientY - moveY; // 이동 시작 Y 좌표
            } else if (e.button === 0) {
                isLeftMouseDown = true; // 좌클릭 상태 설정
                const clickedNode = nodes.slice().reverse().find(node => node.contains(mx, my)); // 클릭한 노드 찾기
                console.log(nodes);
                if (clickedNode) {
                    const index = nodes.indexOf(clickedNode); // 선택된 노드의 인덱스 찾기
                    if (index !== -1) {
                        nodes.splice(index, 1); // 선택된 노드를 배열에서 제거
                        nodes.push(clickedNode); // 선택된 노드를 배열의 최하위로 추가
                    }
                }

                if (e.shiftKey) {
                    // Shift + 좌클릭 시 노드 선택
                    if (clickedNode && !selectedNodes.includes(clickedNode)) {
                        selectedNodes.push(clickedNode); // 선택된 노드에 추가
                        console.log("다중 선택");
                    }
                } else {
                    // 일반 좌클릭 시 클릭한 노드가 선택되지 않은 경우 해당 노드 선택
                    if (clickedNode) {
                        if (!selectedNodes.includes(clickedNode)) {
                            selectedNodes = [clickedNode]; // 단일 선택
                            
                            console.log("단일 선택");
                        } else {
                            // 드래그인지 단일 클릭인지 판단
                            let timer;
                            timer = setInterval(() => {
                                console.log("드래그 대기" + isMouseDragging + " " + !isLeftMouseDown);
                                // 드래그 시 드래그라고 판단
                                if (isMouseDragging) {
                                    clearInterval(timer); // 타이머 중지
                                    console.log("드래그");
                                }
                                // 클릭 해제 시 단일 선택이라고 판단
                                if (!isLeftMouseDown) {
                                    selectedNodes = [clickedNode]; // 단일 선택
                                    console.log("단일 선택");
                                    updateCanvas(); // 캔버스 업데이트
                                    clearInterval(timer); // 타이머 중지
                                }
                            }, 10); // 대기 시간
                        }
                    } else {
                        selectedNodes = []; // 클릭한 노드가 없을 경우 배열 비우기
                        console.log("선택 해제");
                    }
                }

                // 드래그 시작
                if (clickedNode && !e.shiftKey) {
                    isDragging = true; // 드래그 상태 설정
                    selectedNodes.forEach(node => {
                        node.offsetX = mx - node.x; // X 방향 오프셋 계산
                        node.offsetY = my - node.y; // Y 방향 오프셋 계산
                    });
                }
                
                // 드래그 선택 시작
                if (e.button === 0 && !e.shiftKey && !isDragging) {
                    isSelecting = true;
                    selectionStartX = e.offsetX;
                    selectionStartY = e.offsetY;
                    selectionEndX = e.offsetX;
                    selectionEndY = e.offsetY;

                    // 0.1초 간격으로 캔버스를 업데이트
                    selectionInterval = setInterval(() => {
                        updateCanvas();
                    }, 100); // 100ms = 0.1초
                } else {
                    updateCanvas(); // 캔버스 업데이트
                }
            }
        });

        window.addEventListener('mousemove', (e) =>{
            if (isDragging) {
                isMouseDragging = true; // 드래그 상태 설정
            } else {
                isMouseDragging = false; // 드래그 해제
            }

            if (isWheelDragging) {
                // 휠 드래그 시 이동
                moveX = e.clientX - moveXStart;
                moveY = e.clientY - moveYStart;
            } else if (isDragging) {
                selectedNodes.forEach(node => {
                    if (e.ctrlKey) {
                        // Ctrl 키를 누르고 있는 경우 그리드에 맞춰 이동
                        node.initialX = Math.round((e.offsetX - node.offsetX - moveX) / gridSpacing) * gridSpacing;
                        node.initialY = Math.round((e.offsetY - node.offsetY - moveY) / gridSpacing) * gridSpacing;
                    } else {
                        // 일반 드래그
                        node.initialX = e.offsetX - node.offsetX - moveX;
                        node.initialY = e.offsetY - node.offsetY - moveY;
                    }
                });
            }
            updateCanvas(); // 캔버스 업데이트
        }); // 마우스 이동 시 핸들러 설정

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isDragging = false; // 드래그 상태 해제
                isLeftMouseDown = false; // 좌클릭 상태 해제
            }
            if (e.button === 1) isWheelDragging = false; // 휠 드래그 상태 해제

            if (isSelecting) {
                isSelecting = false;
                selectNodesInBox();
                updateCanvas();
                // 드래그 선택이 종료되면 인터벌 제거
                clearInterval(selectionInterval);
            }

            updateCanvas(); // 캔버스 업데이트
        });

        document.getElementById('addNodeBtn').addEventListener('click', () => {
            const centerX = (canvas.width / 2 - moveX);
            const centerY = (canvas.height / 2 - moveY);
            const node = new Node(centerX, centerY);
            nodes.push(node);
            updateCanvas();
        });

        canvas.addEventListener('mousemove', (e) => {
            const mx = e.offsetX; // 마우스 X 좌표
            const my = e.offsetY; // 마우스 Y 좌표
            const hoveredNode = nodes.slice().reverse().find(node => node.contains(mx, my)); // 호버 중인 노드 찾기

            nodes.forEach(node => {
                if (selectedNodes.includes(node)) {
                    node.color = 'selected'; // 선택된 노드 색상 변경
                } else if (node === hoveredNode) {
                    node.color = 'hover'; // 호버된 노드 색상 변경
                } else {
                    node.color = 'normal'; // 기본 색상
                }
            });

            if (isSelecting) {
                selectionEndX = e.offsetX;
                selectionEndY = e.offsetY;
                selectNodesInBox();
                updateCanvas();
            }
            
            updateCanvas(); // 캔버스 업데이트
        });

        updateCanvas(); // 초기 캔버스 업데이트
    </script>

</body>
</html>
